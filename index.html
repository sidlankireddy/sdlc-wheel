<script>
/* Auto-centering + collision-aware label placement for SDLC Wheel
   Drop-in: replace your existing script block with this.
   - Measures the wheel bounding box at runtime (true pixel center)
   - Places each label on the sector bisector at a proportional radius
   - Nudges outward until it doesn't overlap the center or earlier labels
   - Recomputes on resize (debounced)
*/

(function(){
  console.log("SDLC wheel script (auto-center + collision avoidance) initializing...");

  /* helper: hex -> rgba */
  function hexToRgba(hex,a){
    hex = (hex || '#999').replace('#','');
    if (hex.length === 3) hex = hex.split('').map(c=>c+c).join('');
    const r = parseInt(hex.slice(0,2),16),
          g = parseInt(hex.slice(2,4),16),
          b = parseInt(hex.slice(4,6),16);
    return `rgba(${r},${g},${b},${a})`;
  }

  /* phases array (keeps your SharePoint links) */
  const phases = [
    { name: "Planning & Analysis", angle: 15, color: "#2B5F90", link: "https://shiftup.sharepoint.com/sites/ICT-India-AI-SDLC-Hub/Planning%20%20Analysis" },
    { name: "Design", angle: 85, color: "#B8792F", link: "https://shiftup.sharepoint.com/sites/ICT-India-AI-SDLC-Hub/Design%20Accelerators/Forms/AllItems.aspx" },
    { name: "Implementation", angle: 160, color: "#BB4C46", link: "https://shiftup.sharepoint.com/sites/ICT-India-AI-SDLC-Hub/Implementation%20Accelerators/Forms/AllItems.aspx" },
    { name: "Testing & Integration", angle: 220, color: "#D8B441", link: "https://shiftup.sharepoint.com/sites/ICT-India-AI-SDLC-Hub/Testing%20%20Integration/Forms/AllItems.aspx" },
    { name: "Deployment & Operations", angle: 285, color: "#3B9A95", link: "https://shiftup.sharepoint.com/sites/ICT-India-AI-SDLC-Hub/Deployment%20%20Operations%20Accelerators/Forms/AllItems.aspx" },
    { name: "Maintenance", angle: 325, color: "#6656E6", link: "https://shiftup.sharepoint.com/sites/ICT-India-AI-SDLC-Hub/Maintenance/Forms/AllItems.aspx" }
  ];

  // optional manual nudges fallback (tiny optical offsets) - mostly unused by auto placement
  const nudges = {
    "Planning & Analysis":      { rx: 0,  ry: 0 },
    "Design":                   { rx: 0,  ry: 0 },
    "Implementation":           { rx: 0,  ry: 0 },
    "Testing & Integration":    { rx: 0,  ry: 0 },
    "Deployment & Operations":  { rx: 0,  ry: 0 },
    "Maintenance":              { rx: 0,  ry: 0 }
  };

  const wheelEl = document.getElementById('wheel');
  const hoverPanel = document.getElementById('hover-panel');

  if (!wheelEl) {
    console.warn("SDLC wheel script: #wheel element not found on page.");
    return;
  }

  // Intersection / overlap check (AABB)
  function intersects(a, b) {
    return !(a.left + a.width <= b.left || b.left + b.width <= a.left || a.top + a.height <= b.top || b.top + b.height <= a.top);
  }

  // Convert screen coords to wheel-local coordinates for placement
  function screenToLocal(screenX, screenY, wheelRect, labelSize) {
    const leftLocal = screenX - (window.scrollX + wheelRect.left) - (labelSize / 2);
    const topLocal  = screenY - (window.scrollY + wheelRect.top)  - (labelSize / 2);
    return { leftLocal, topLocal };
  }

  // Short descriptions (for hover panel)
  function getShortDesc(n) {
    switch(n){
      case "Planning & Analysis": return "Requirements gathering, feasibility checks and scope definition.";
      case "Design": return "Solution architecture, UX planning and technical design.";
      case "Implementation": return "Development and build activities aligned to defined designs.";
      case "Testing & Integration": return "Functional testing, regression, validation and system integration.";
      case "Deployment & Operations": return "Release preparation, deployment execution, monitoring and operations.";
      case "Maintenance": return "Enhancements, fixes, optimizations and continuous improvements.";
      default: return "";
    }
  }

  // Main placement routine
  function placeLabelsAuto() {
    // remove old labels
    Array.from(wheelEl.querySelectorAll('.phase-label')).forEach(n => n.remove());

    const rect = wheelEl.getBoundingClientRect();
    const wheelLeft = rect.left;
    const wheelTop  = rect.top;
    const wheelWidth = rect.width;
    const wheelHeight = rect.height;
    const wheelCenter = { x: wheelLeft + wheelWidth/2, y: wheelTop + wheelHeight/2 };

    // CSS variable base scale (use declared root wheel size to calculate scaled label size)
    const rootWheel = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--wheel-size')) || 560;
    const cssLabelSize = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--label-size')) || 110;
    const scaledLabelSize = Math.max(72, Math.round(cssLabelSize * (wheelWidth / rootWheel))); // min 72px

    // center element effective radius (approx half of center-size)
    const cssCenterSize = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--center-size')) || 170;
    const scaledCenterRadius = (cssCenterSize * (wheelWidth / rootWheel)) / 2;

    // label start radius proportional to wheel size (tweak multiplier to move labels closer/further)
    const baseLabelRadius = Math.round((wheelWidth / 2) * 0.61); // ~61% of wheel radius

    // keeps boxes of labels already placed to avoid overlap
    const placedBoxes = [];

    // function to compute screen coords for angle and radius
    function computeScreenXY(angleDeg, radius) {
      const theta = (angleDeg - 90) * Math.PI / 180;
      const x = Math.round(wheelCenter.x + radius * Math.cos(theta));
      const y = Math.round(wheelCenter.y + radius * Math.sin(theta));
      return { x, y };
    }

    // For each phase, place label with outward steps until no overlap
    phases.forEach((p) => {
      // create DOM element hidden initially
      const el = document.createElement('div');
      el.className = 'phase-label';
      el.style.width = `${scaledLabelSize}px`;
      el.style.height = `${scaledLabelSize}px`;
      el.style.background = hexToRgba(p.color, 0.28);
      el.innerHTML = (p.name === "Implementation") ? p.name.replace(/\s+/g,'&nbsp;') : p.name;
      // append invisible for measurement
      el.style.visibility = 'hidden';
      wheelEl.appendChild(el);

      // trial placement
      const step = Math.max(6, Math.round(scaledLabelSize * 0.06)); // outward step each trial
      let r = baseLabelRadius;
      const maxR = Math.round(wheelWidth * 0.7);
      let safe = false;
      let trials = 0;
      let finalLocal = { leftLocal: 0, topLocal: 0 };

      while (!safe && trials < 100 && r <= maxR) {
        const { x: sx, y: sy } = computeScreenXY(p.angle, r);
        const local = screenToLocal(sx, sy, rect, scaledLabelSize);

        // check within wheel boundary: label center must stay within wheelRadius - small margin
        const dx = sx - wheelCenter.x;
        const dy = sy - wheelCenter.y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        const wheelRadius = wheelWidth/2;
        if (dist + (scaledLabelSize/2) > wheelRadius + 4) {
          // too far out -> break loop (we'll clamp later)
          break;
        }

        // center collision
        const centerDist = Math.sqrt(Math.pow(sx - wheelCenter.x,2) + Math.pow(sy - wheelCenter.y,2));
        if (centerDist < scaledCenterRadius + (scaledLabelSize/2) + 6) {
          r += step; trials++; continue;
        }

        // generate candidate box in wheel-local coords
        const cand = { left: Math.round(local.leftLocal), top: Math.round(local.topLocal), width: scaledLabelSize, height: scaledLabelSize };

        // collision with previously placed?
        let overlap = false;
        for (const b of placedBoxes) {
          if (intersects(cand, b)) { overlap = true; break; }
        }
        if (overlap) { r += step; trials++; continue; }

        // passed all checks
        finalLocal = cand;
        safe = true;
      }

      // fallback: if not safe, clamp to base radius position
      if (!safe) {
        const { x: sx, y: sy } = computeScreenXY(p.angle, baseLabelRadius);
        const local = screenToLocal(sx, sy, rect, scaledLabelSize);
        finalLocal = { left: Math.round(local.leftLocal), top: Math.round(local.topLocal), width: scaledLabelSize, height: scaledLabelSize };
      }

      // set final placement
      el.style.left = `${finalLocal.left}px`;
      el.style.top  = `${finalLocal.top}px`;
      el.style.visibility = 'visible';

      // save box
      placedBoxes.push({ left: finalLocal.left, top: finalLocal.top, width: finalLocal.width, height: finalLocal.height });

      // hover panel & click
      el.addEventListener('mouseenter', () => {
        hoverPanel.style.display = 'block';
        hoverPanel.innerHTML = `<strong style="color:#003a6c">${p.name}</strong><div style="margin-top:6px;color:#333;font-size:13px">${getShortDesc(p.name)}</div>`;
        const rct = el.getBoundingClientRect();
        let left = rct.right + 12;
        let top  = rct.top;
        if (left + 260 > window.innerWidth) left = rct.left - 260 - 12;
        if (top + 120 > window.innerHeight) top = window.innerHeight - 140;
        hoverPanel.style.left = left + 'px';
        hoverPanel.style.top  = top + 'px';
      });
      el.addEventListener('mouseleave', () => hoverPanel.style.display = 'none');
      el.addEventListener('click', () => window.open(p.link, '_blank'));
    }); // end forEach
  } // end placeLabelsAuto

  // initial placement and responsive handling
  function refreshLabelsDebounced() {
    clearTimeout(window.__sdlc_place_labels_timer);
    window.__sdlc_place_labels_timer = setTimeout(() => {
      try { placeLabelsAuto(); }
      catch(e){ console.error("Error in placeLabelsAuto:", e); }
    }, 90);
  }

  window.addEventListener('load', refreshLabelsDebounced);
  window.addEventListener('resize', refreshLabelsDebounced);
  // if your app manipulates layout dynamically, you can call placeLabelsAuto() manually after changes

  // immediate run if DOM already loaded
  if (document.readyState === 'complete' || document.readyState === 'interactive') {
    refreshLabelsDebounced();
  }

  console.log("SDLC wheel script loaded (auto-center).");
})();
</script>
