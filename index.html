<script>
/* Auto-center + micro-nudges (safe, debounced, collision-aware)
   Replace your existing script with this block.
*/
(function(){
  // safe logging
  console.log("SDLC wheel (auto-center + micro-nudges) initializing...");

  function hexToRgba(hex,a){
    try{
      hex=(hex||'#999').replace('#','');
      if(hex.length===3) hex=hex.split('').map(c=>c+c).join('');
      const r=parseInt(hex.slice(0,2),16), g=parseInt(hex.slice(2,4),16), b=parseInt(hex.slice(4,6),16);
      return `rgba(${r},${g},${b},${a})`;
    }catch(e){ return `rgba(150,150,150,${a})`; }
  }

  const phases = [
    { name:"Planning & Analysis", angle:15,  color:"#2B5F90", link:"https://shiftup.sharepoint.com/sites/ICT-India-AI-SDLC-Hub/Planning%20%20Analysis" },
    { name:"Design",               angle:85,  color:"#B8792F", link:"https://shiftup.sharepoint.com/sites/ICT-India-AI-SDLC-Hub/Design%20Accelerators/Forms/AllItems.aspx" },
    { name:"Implementation",       angle:160, color:"#BB4C46", link:"https://shiftup.sharepoint.com/sites/ICT-India-AI-SDLC-Hub/Implementation%20Accelerators/Forms/AllItems.aspx" },
    { name:"Testing & Integration",angle:220, color:"#D8B441", link:"https://shiftup.sharepoint.com/sites/ICT-India-AI-SDLC-Hub/Testing%20%20Integration/Forms/AllItems.aspx" },
    { name:"Deployment & Operations",angle:285,color:"#3B9A95", link:"https://shiftup.sharepoint.com/sites/ICT-India-AI-SDLC-Hub/Deployment%20%20Operations%20Accelerators/Forms/AllItems.aspx" },
    { name:"Maintenance",          angle:325, color:"#6656E6", link:"https://shiftup.sharepoint.com/sites/ICT-India-AI-SDLC-Hub/Maintenance/Forms/AllItems.aspx" }
  ];

  // micro-nudges (pixels) — conservative, optical tweaks
  // rx: extra radius (positive = outward, negative = inward)
  // ry: vertical pixel shift on final placement (positive = down, negative = up)
  const nudges = {
    "Planning & Analysis":      { rx: -6, ry: +6 },
    "Design":                   { rx: 0,   ry: 0  },
    "Implementation":           { rx: -8, ry: -18 }, // move up & slightly inward
    "Testing & Integration":    { rx: +3, ry: -4 },
    "Deployment & Operations":  { rx: +10, ry: -6 },  // outward & up
    "Maintenance":              { rx: +6, ry: +4 }
  };

  const wheelEl = document.getElementById('wheel');
  const hoverPanel = document.getElementById('hover-panel');

  if (!wheelEl) {
    console.warn("SDLC wheel script: '#wheel' not found — aborting.");
    return;
  }

  function intersects(a,b){
    return !(a.left + a.width <= b.left || b.left + b.width <= a.left || a.top + a.height <= b.top || b.top + b.height <= a.top);
  }

  function screenToLocal(screenX, screenY, wheelRect, labelSize){
    const leftLocal = screenX - (window.scrollX + wheelRect.left) - (labelSize/2);
    const topLocal  = screenY - (window.scrollY + wheelRect.top)  - (labelSize/2);
    return { leftLocal, topLocal };
  }

  function getShortDesc(n){
    switch(n){
      case "Planning & Analysis": return "Requirements gathering, feasibility checks and scope definition.";
      case "Design": return "Solution architecture, UX planning and technical design.";
      case "Implementation": return "Development and build activities aligned to defined designs.";
      case "Testing & Integration": return "Functional testing, regression, validation and system integration.";
      case "Deployment & Operations": return "Release preparation, deployment execution, monitoring and operations.";
      case "Maintenance": return "Enhancements, fixes, optimizations and continuous improvements.";
      default: return "";
    }
  }

  function placeLabelsAuto(){
    // clear previous
    Array.from(document.querySelectorAll('.phase-label')).forEach(n=>n.remove());

    const rect = wheelEl.getBoundingClientRect();
    if (!rect || rect.width === 0) {
      console.warn("Wheel geometry not ready — skipping placement.");
      return;
    }

    const wheelCenter = { x: rect.left + rect.width/2, y: rect.top + rect.height/2 };
    const wheelRadius = rect.width/2;

    const rootWheel = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--wheel-size')) || 560;
    const cssLabelSize = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--label-size')) || 102;
    const labelSize = Math.max(72, Math.round(cssLabelSize * (rect.width / rootWheel)));

    // base radius for labels (proportional)
    const baseLabelRadius = Math.round((rect.width/2) * 0.60);

    const placed = [];

    phases.forEach(p => {
      try {
        const el = document.createElement('div');
        el.className = 'phase-label';
        el.style.width  = `${labelSize}px`;
        el.style.height = `${labelSize}px`;
        el.style.background = hexToRgba(p.color, 0.28);
        el.style.whiteSpace = 'nowrap';
        el.style.textAlign = 'center';
        el.style.lineHeight = '1.05';
        el.style.fontWeight = '700';
        el.innerHTML = (p.name === "Implementation") ? p.name.replace(/\s+/g, '&nbsp;') : p.name;
        el.style.visibility = 'hidden';
        wheelEl.appendChild(el);

        const nud = nudges[p.name] || { rx:0, ry:0 };

        const theta = (p.angle - 90) * Math.PI / 180;
        const step = Math.max(6, Math.round(labelSize * 0.06));
        let r = baseLabelRadius + (nud.rx || 0);
        const maxR = Math.round(rect.width * 0.72);
        let safe = false;
        let trials = 0;
        let finalLocal = { left: 0, top: 0, width: labelSize, height: labelSize };

        while(!safe && trials < 80 && r <= maxR) {
          const xScreen = Math.round(wheelCenter.x + r * Math.cos(theta));
          const yScreen = Math.round(wheelCenter.y + r * Math.sin(theta)) + (nud.ry || 0);
          const local = screenToLocal(xScreen, yScreen, rect, labelSize);

          // ensure center-of-label inside wheel
          const dx = xScreen - wheelCenter.x;
          const dy = yScreen - wheelCenter.y;
          const dist = Math.sqrt(dx*dx + dy*dy);
          if (dist + (labelSize/2) > wheelRadius + 6) {
            // too far out -> stop outwarding
            break;
          }

          // avoid hitting center region (center-size)
          const cssCenterSize = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--center-size')) || 170;
          const scaledCenterRadius = (cssCenterSize * (rect.width / rootWheel)) / 2;
          const centerDist = Math.sqrt(Math.pow(xScreen - wheelCenter.x,2) + Math.pow(yScreen - wheelCenter.y,2));
          if (centerDist < scaledCenterRadius + (labelSize/2) + 6) { r += step; trials++; continue; }

          const cand = { left: Math.round(local.leftLocal), top: Math.round(local.topLocal), width: labelSize, height: labelSize };
          let overlap = false;
          for (const b of placed) { if (intersects(cand, b)) { overlap = true; break; } }
          if (overlap) { r += step; trials++; continue; }

          // ok
          finalLocal = cand; safe = true;
        }

        if (!safe) {
          // fallback — place at base radius with nudge applied
          const xScreen = Math.round(wheelCenter.x + baseLabelRadius * Math.cos(theta));
          const yScreen = Math.round(wheelCenter.y + baseLabelRadius * Math.sin(theta)) + (nud.ry || 0);
          const local = screenToLocal(xScreen, yScreen, rect, labelSize);
          finalLocal = { left: Math.round(local.leftLocal), top: Math.round(local.topLocal), width: labelSize, height: labelSize };
        }

        el.style.left = `${finalLocal.left}px`;
        el.style.top  = `${finalLocal.top}px`;
        el.style.visibility = 'visible';

        placed.push({ left: finalLocal.left, top: finalLocal.top, width: finalLocal.width, height: finalLocal.height });

        // hover
        el.addEventListener('mouseenter', () => {
          if (!hoverPanel) return;
          hoverPanel.style.display = 'block';
          hoverPanel.innerHTML = `<strong style="color:#003a6c">${p.name}</strong><div style="margin-top:6px;color:#333;font-size:13px">${getShortDesc(p.name)}</div>`;
          const rct = el.getBoundingClientRect();
          let left = rct.right + 12;
          let top = rct.top;
          if (left + 260 > window.innerWidth) left = rct.left - 260 - 12;
          if (top + 120 > window.innerHeight) top = window.innerHeight - 140;
          hoverPanel.style.left = left + 'px';
          hoverPanel.style.top  = top + 'px';
        });
        el.addEventListener('mouseleave', () => { if (hoverPanel) hoverPanel.style.display = 'none'; });
        el.addEventListener('click', () => { if (p.link) window.open(p.link, '_blank'); });

      } catch(e) {
        console.warn("label placement error for", p.name, e);
      }
    }); // phases loop
  } // placeLabelsAuto

  // small helper duplicate of getShortDesc used inside
  function getShortDesc(n){
    switch(n){
      case "Planning & Analysis": return "Requirements gathering, feasibility checks and scope definition.";
      case "Design": return "Solution architecture, UX planning and technical design.";
      case "Implementation": return "Development and build activities aligned to defined designs.";
      case "Testing & Integration": return "Functional testing, regression, validation and system integration.";
      case "Deployment & Operations": return "Release preparation, deployment execution, monitoring and operations.";
      case "Maintenance": return "Enhancements, fixes, optimizations and continuous improvements.";
      default: return "";
    }
  }

  // debounce and lifecycle
  const deb = () => { clearTimeout(window.__sdlc_timer); window.__sdlc_timer = setTimeout(() => { try { placeLabelsAuto(); } catch(e){console.error(e);} }, 90); };
  window.addEventListener('load', deb);
  window.addEventListener('resize', deb);
  if (document.readyState === 'complete' || document.readyState === 'interactive') deb();

  console.log("SDLC wheel (auto-center + micro-nudges) active.");
})();
</script>
