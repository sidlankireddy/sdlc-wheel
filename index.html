<script>
(function(){
  try {
    console.log("SDLC wheel (auto-center) — initializing (hardened)...");
    // helper: hex -> rgba
    function hexToRgba(hex,a){
      try {
        hex = (hex||'#999').replace('#','').trim();
        if(hex.length===3) hex = hex.split('').map(c=>c+c).join('');
        const r = parseInt(hex.slice(0,2),16);
        const g = parseInt(hex.slice(2,4),16);
        const b = parseInt(hex.slice(4,6),16);
        if (Number.isNaN(r)||Number.isNaN(g)||Number.isNaN(b)) return `rgba(150,150,150,${a})`;
        return `rgba(${r},${g},${b},${a})`;
      } catch(e){ return `rgba(150,150,150,${a})`; }
    }

    const phases = [
      { name: "Planning & Analysis", angle: 15, color: "#2B5F90", link: "https://shiftup.sharepoint.com/sites/ICT-India-AI-SDLC-Hub/Planning%20%20Analysis" },
      { name: "Design", angle: 85, color: "#B8792F", link: "https://shiftup.sharepoint.com/sites/ICT-India-AI-SDLC-Hub/Design%20Accelerators/Forms/AllItems.aspx" },
      { name: "Implementation", angle: 160, color: "#BB4C46", link: "https://shiftup.sharepoint.com/sites/ICT-India-AI-SDLC-Hub/Implementation%20Accelerators/Forms/AllItems.aspx" },
      { name: "Testing & Integration", angle: 220, color: "#D8B441", link: "https://shiftup.sharepoint.com/sites/ICT-India-AI-SDLC-Hub/Testing%20%20Integration/Forms/AllItems.aspx" },
      { name: "Deployment & Operations", angle: 285, color: "#3B9A95", link: "https://shiftup.sharepoint.com/sites/ICT-India-AI-SDLC-Hub/Deployment%20%20Operations%20Accelerators/Forms/AllItems.aspx" },
      { name: "Maintenance", angle: 325, color: "#6656E6", link: "https://shiftup.sharepoint.com/sites/ICT-India-AI-SDLC-Hub/Maintenance/Forms/AllItems.aspx" }
    ];

    const wheelEl = document.getElementById('wheel');
    const hoverPanel = document.getElementById('hover-panel');

    if (!wheelEl) {
      console.warn("SDLC wheel script: '#wheel' element not found - aborting script (safe).");
      return;
    }

    function intersects(a,b){
      return !(a.left + a.width <= b.left || b.left + b.width <= a.left || a.top + a.height <= b.top || b.top + b.height <= a.top);
    }

    function screenToLocal(screenX, screenY, wheelRect, labelSize){
      const leftLocal = screenX - (window.scrollX + wheelRect.left) - (labelSize / 2);
      const topLocal  = screenY - (window.scrollY + wheelRect.top)  - (labelSize / 2);
      return { leftLocal, topLocal };
    }

    function getShortDesc(n){
      switch(n){
        case "Planning & Analysis": return "Requirements gathering, feasibility checks and scope definition.";
        case "Design": return "Solution architecture, UX planning and technical design.";
        case "Implementation": return "Development and build activities aligned to defined designs.";
        case "Testing & Integration": return "Functional testing, regression, validation and system integration.";
        case "Deployment & Operations": return "Release preparation, deployment execution, monitoring and operations.";
        case "Maintenance": return "Enhancements, fixes, optimizations and continuous improvements.";
        default: return "";
      }
    }

    function placeLabelsAuto() {
      // safe remove (no throw)
      try {
        Array.from(wheelEl.querySelectorAll('.phase-label')).forEach(n=>n.remove());
      } catch(e){}

      const rect = wheelEl.getBoundingClientRect();
      if (!rect || rect.width === 0) {
        console.warn("Wheel bounding box not measurable yet — skipping this tick.");
        return;
      }

      const wheelLeft = rect.left;
      const wheelTop  = rect.top;
      const wheelWidth = rect.width;
      const wheelCenter = { x: wheelLeft + wheelWidth/2, y: wheelTop + wheelWidth/2 };

      // CSS vars fallback parsing
      const rootWheel = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--wheel-size')) || 560;
      const cssLabelSize = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--label-size')) || 110;
      const scaledLabelSize = Math.max(72, Math.round(cssLabelSize * (wheelWidth / rootWheel)));

      const cssCenterSize = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--center-size')) || 170;
      const scaledCenterRadius = (cssCenterSize * (wheelWidth / rootWheel)) / 2;

      const baseLabelRadius = Math.round((wheelWidth / 2) * 0.61);

      const placedBoxes = [];

      function computeScreenXY(angleDeg, radius){
        const theta = (angleDeg - 90) * Math.PI / 180;
        const x = Math.round(wheelCenter.x + radius * Math.cos(theta));
        const y = Math.round(wheelCenter.y + radius * Math.sin(theta));
        return { x, y };
      }

      phases.forEach((p) => {
        try {
          const el = document.createElement('div');
          el.className = 'phase-label';
          el.style.width = `${scaledLabelSize}px`;
          el.style.height = `${scaledLabelSize}px`;
          el.style.background = hexToRgba(p.color, 0.28);
          el.innerHTML = (p.name === "Implementation") ? p.name.replace(/\s+/g,'&nbsp;') : p.name;
          el.style.visibility = 'hidden';
          wheelEl.appendChild(el);

          const step = Math.max(6, Math.round(scaledLabelSize * 0.06));
          let r = baseLabelRadius;
          const maxR = Math.round(wheelWidth * 0.72);
          let safe = false;
          let trials = 0;
          let finalLocal = { left: 0, top: 0, width: scaledLabelSize, height: scaledLabelSize };

          while(!safe && trials < 80 && r <= maxR) {
            const { x: sx, y: sy } = computeScreenXY(p.angle, r);
            const local = screenToLocal(sx, sy, rect, scaledLabelSize);

            const dx = sx - wheelCenter.x;
            const dy = sy - wheelCenter.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            const wheelRadius = wheelWidth / 2;
            if (dist + (scaledLabelSize / 2) > wheelRadius + 6) { break; }

            const centerDist = Math.sqrt(Math.pow(sx - wheelCenter.x,2) + Math.pow(sy - wheelCenter.y,2));
            if (centerDist < scaledCenterRadius + (scaledLabelSize/2) + 6) { r += step; trials++; continue; }

            const cand = { left: Math.round(local.leftLocal), top: Math.round(local.topLocal), width: scaledLabelSize, height: scaledLabelSize };

            let overlap = false;
            for (const b of placedBoxes) { if (intersects(cand,b)) { overlap = true; break; } }
            if (overlap) { r += step; trials++; continue; }

            finalLocal = cand; safe = true;
          }

          if (!safe) {
            const { x: sx, y: sy } = computeScreenXY(p.angle, baseLabelRadius);
            const local = screenToLocal(sx, sy, rect, scaledLabelSize);
            finalLocal = { left: Math.round(local.leftLocal), top: Math.round(local.topLocal), width: scaledLabelSize, height: scaledLabelSize };
          }

          el.style.left = `${finalLocal.left}px`;
          el.style.top  = `${finalLocal.top}px`;
          el.style.visibility = 'visible';

          placedBoxes.push({ left: finalLocal.left, top: finalLocal.top, width: finalLocal.width, height: finalLocal.height });

          el.addEventListener('mouseenter', () => {
            try {
              if (!hoverPanel) return;
              hoverPanel.style.display = 'block';
              hoverPanel.innerHTML = `<strong style="color:#003a6c">${p.name}</strong><div style="margin-top:6px;color:#333;font-size:13px">${getShortDesc(p.name)}</div>`;
              const rct = el.getBoundingClientRect();
              let left = rct.right + 12;
              let top  = rct.top;
              if (left + 260 > window.innerWidth) left = rct.left - 260 - 12;
              if (top + 120 > window.innerHeight) top = window.innerHeight - 140;
              hoverPanel.style.left = left + 'px';
              hoverPanel.style.top  = top + 'px';
            } catch(e){}
          });
          el.addEventListener('mouseleave', () => { try { if (hoverPanel) hoverPanel.style.display = 'none'; } catch(e){} });
          el.addEventListener('click', () => { try { if (p.link) window.open(p.link, '_blank'); } catch(e){} });

        } catch(innerE){
          console.warn("Failed placing one label, continuing...", innerE);
        }
      });

    } // end placeLabelsAuto

    // debounce wrapper
    function refreshLabelsDebounced(){
      clearTimeout(window.__sdlc_place_labels_timer);
      window.__sdlc_place_labels_timer = setTimeout(()=> {
        try { placeLabelsAuto(); }
        catch(e){ console.error("placeLabelsAuto error:", e); }
      }, 100);
    }

    // run on load / resize safely
    window.addEventListener('load', refreshLabelsDebounced);
    window.addEventListener('resize', refreshLabelsDebounced);
    if (document.readyState === 'complete' || document.readyState === 'interactive') refreshLabelsDebounced();

    console.log("SDLC wheel (auto-center) — loaded safely.");
  } catch(e){
    console.error("Fatal error in SDLC wheel script (caught):", e);
    // do not rethrow — page must remain usable
  }
})();
</script>
